package utils

import (
	"fmt"
	"math"
)

const (
	maxStrokeSize = 4
	minStrokeSize = 2
)

// TraceStatistics contains aggregated statistics from a trace
type TraceStatistics struct {
	Errors    map[string]string  // port -> error message
	Latencies map[string]float64 // port/edge key -> latency in ms
	Sequence  []string           // ordered list of visited ports/edges
	Data      map[string]struct{}
}

// NewTraceStatistics creates a new TraceStatistics instance
func NewTraceStatistics() *TraceStatistics {
	return &TraceStatistics{
		Errors:    make(map[string]string),
		Latencies: make(map[string]float64),
		Sequence:  make([]string, 0),
		Data:      make(map[string]struct{}),
	}
}

// ExtractTraceStatistics extracts trace statistics and runtime data from a trace
// Returns TraceStatistics and a map of port -> data bytes
func ExtractTraceStatistics(trace *TraceData) (*TraceStatistics, map[string][]byte) {
	if trace == nil {
		return NewTraceStatistics(), nil
	}

	ts := NewTraceStatistics()
	runtimeData := make(map[string][]byte)

	for _, span := range trace.Spans {
		var port, from, to, errMsg string

		// Extract attributes from span
		for _, a := range span.Attributes {
			switch a.Key {
			case "from":
				from = a.Value // port name only
			case "to":
				to = a.Value // fullname
			case "port":
				port = a.Value
			}
		}

		// Search for errors in events
		for _, e := range span.Events {
			if e.Name == "error" || e.Name == "exception" {
				for _, a := range e.Attributes {
					if a.Key == "exception.message" {
						errMsg = a.Value
					}
				}
			}
			// Also capture expression evaluation errors
			if e.Name == "expression_error" {
				var expr, exprErr string
				for _, a := range e.Attributes {
					switch a.Key {
					case "expression":
						expr = a.Value
					case "error":
						exprErr = a.Value
					}
				}
				if expr != "" && exprErr != "" {
					errMsg = fmt.Sprintf("expression {{%s}}: %s", expr, exprErr)
				}
			}
		}

		latency := float64((span.EndTimeUnixNano - span.StartTimeUnixNano) / 1000_000)
		key := port

		if port == "" {
			// to make it apply to edge
			// but only if from is not generated by the signal (then its not a real edge)
			if from != "signal" {
				key = from + to
			} else {
				key = to
			}
			port = to
		}

		if errMsg != "" {
			ts.Errors[port] = errMsg
		}

		if key == "" {
			// ignore spans produced by other subsystems like grpc
			continue
		}

		ts.Latencies[key] = ts.Latencies[key] + latency
		ts.Sequence = append(ts.Sequence, key)

		// Search for data in events
		var foundData bool
		for _, e := range span.Events {
			if e.Name != "data" {
				continue
			}

			for _, a := range e.Attributes {
				if a.Key != "payload" {
					continue
				}
				foundData = true
				if a.Value != "" {
					ts.Data[key] = struct{}{}
					runtimeData[port] = []byte(a.Value)
				} else {
					// Mark as visited but with no data (empty payload)
					runtimeData[port] = nil
				}
				break
			}
		}

		// If span has port but no data event at all, mark as visited with no data
		// This ensures we don't fall back to fake data for traced ports
		if !foundData && port != "" {
			if _, exists := runtimeData[port]; !exists {
				runtimeData[port] = nil
			}
		}
	}

	return ts, runtimeData
}

// ApplyTraceStatToNode applies trace statistics to a node map for visualization
func ApplyTraceStatToNode(nodeMap map[string]interface{}, ts *TraceStatistics) {
	if ts == nil {
		return
	}

	nodeID := GetStr(nodeMap["id"])
	data, ok := nodeMap["data"].(map[string]interface{})
	if !ok {
		return
	}

	handles, ok := data["handles"].([]interface{})
	if !ok {
		return
	}

	var hasError bool

	// First pass: check for errors on handles
	for _, handle := range handles {
		handleMap, ok := handle.(map[string]interface{})
		if !ok {
			continue
		}
		target := GetPortFullName(nodeID, GetStr(handleMap["id"]))

		if er, ok := ts.Errors[target]; ok {
			handleMap["error"] = er
			hasError = true
		}
	}

	// Second pass: find latency for source handles
	for _, handle := range handles {
		handleMap, ok := handle.(map[string]interface{})
		if !ok {
			continue
		}

		target := GetPortFullName(nodeID, GetStr(handleMap["id"]))

		if GetStr(handleMap["type"]) == "target" {
			continue
		}

		lat, ok := ts.Latencies[target]
		if !ok {
			continue
		}

		data["trace"] = map[string]interface{}{
			"error":    hasError,
			"latency":  lat,
			"port":     GetStr(handleMap["id"]),
			"sequence": getIndexByValue(ts.Sequence, target),
		}
		return
	}

	// Fallback: check non-visible ports (like setting or control ports)
	for port, lat := range ts.Latencies {
		node, portName := ParseFullPortName(port)
		if node != nodeID {
			continue
		}
		data["trace"] = map[string]interface{}{
			"error":    hasError,
			"latency":  lat,
			"port":     portName,
			"sequence": getIndexByValue(ts.Sequence, port),
		}
		return
	}

	if hasError {
		data["trace"] = map[string]interface{}{
			"error": hasError,
		}
	}
}

// ApplyTraceStatToEdge applies trace statistics to an edge map for visualization
func ApplyTraceStatToEdge(edgeMap map[string]interface{}, ts *TraceStatistics) {
	if ts == nil {
		return
	}

	to := GetPortFullName(GetStr(edgeMap["target"]), GetStr(edgeMap["targetHandle"]))
	from := GetPortFullName(GetStr(edgeMap["source"]), GetStr(edgeMap["sourceHandle"]))

	_, hasLatency := ts.Latencies[from+to]

	data, ok := edgeMap["data"].(map[string]interface{})
	if !ok {
		data = make(map[string]interface{})
		edgeMap["data"] = data
	}

	seq := getIndexByValue(ts.Sequence, from+to)

	traceInfo := map[string]interface{}{
		"latency":  ts.Latencies[from+to],
		"sequence": seq,
	}

	if er, ok := ts.Errors[from]; ok {
		traceInfo["error"] = er
	}

	if er, ok := ts.Errors[to]; ok {
		traceInfo["error"] = er
	}

	data["trace"] = traceInfo

	// Stroke width for trace visualization (color is handled by frontend)
	if hasLatency {
		style, ok := edgeMap["style"].(map[string]interface{})
		if !ok {
			style = make(map[string]interface{})
			edgeMap["style"] = style
		}
		style["strokeWidth"] = getStrokeWidth(seq, len(ts.Sequence))
	}
}

// getIndexByValue returns the index of a value in a slice, or -1 if not found
func getIndexByValue(in []string, s string) int {
	for k, v := range in {
		if v == s {
			return k
		}
	}
	return -1
}

// getStrokeWidth calculates stroke width based on sequence position
func getStrokeWidth(seq, total int) string {
	rate := float64(maxStrokeSize) / float64(total)
	return fmt.Sprintf("%fpx", math.Max(rate*float64(total-seq), minStrokeSize))
}
